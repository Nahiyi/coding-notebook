Demo 日志结果完全符合 Netty 的 Pipeline 机制。

核心测试点在于 `In-3` 中调用的代码：
```java
ch.writeAndFlush(...)
```

为了理解其中的机制以及可能遇到的问题，需要分析 `Pipeline` 的结构并解释 **`channel.write`** 与 **`ctx.write`** 的区别。

---

### 1. Pipeline 结构

代码中使用 `addLast` 顺序添加处理器，Netty 内部将其组织为一个**双向链表**。
顺序如下：

`Head` <-> `In-1` <-> `In-2` <-> `In-3` <-> `Out-1` <-> `Out-2` <-> `Out-3` <-> `Tail`

---

### 2. 日志结果为 Out3 -> Out2 -> Out1 的原因

#### 入站 (Inbound) 流程：
*   **方向**：从 Head 向 Tail 传播。
*   **动作**：客户端发送数据时，数据从 Head 进入，依次经过 `ChannelInboundHandler`。
*   **路径**：Head -> **In-1** -> **In-2** -> **In-3** -> (Out 处理器被跳过) -> Tail。
*   **日志**：因此日志显示 `In-1` -> `In-2` -> `In-3`。

#### 出站 (Outbound) 流程：
*   **方向**：从 Tail 向 Head 传播（反向）。
*   **动作**：写入数据时，数据需要依次经过 `ChannelOutboundHandler` 进行处理（例如编码），最终到达 Head 并写入 Socket。

**关键点：**
`In-3` 中调用的是 `ch.writeAndFlush(...)`（或 `pipeline.writeAndFlush`）。

*   **`ch.writeAndFlush` 的含义**：从流水线的**最末尾 (Tail)** 开始，向前寻找出站处理器。
*   **路径**：
    1.  从 **Tail** 开始。
    2.  向前查找 -> **Out-3** (出站处理器，执行)。
    3.  向前查找 -> **Out-2** (出站处理器，执行)。
    4.  向前查找 -> **Out-1** (出站处理器，执行)。
    5.  向前查找 -> **In-3** (入站处理器，跳过)。
    6.  ...
    7.  最终到达 **Head**，将数据写入网卡。

**因此日志顺序完全对应：Out-3 -> Out-2 -> Out-1。**

---

### 3. 修改代码后的差异

Netty 初学者容易在此处遇到问题。

若在 `In-3` 中将代码改为使用 `ctx`（上下文）进行写入：

```java
// 修改前
ch.writeAndFlush(...) 

// 修改后
ctx.writeAndFlush(...)
```

**后果：**
所有 Outbound 日志（Out-3, Out-2, Out-1）**均不会打印**，数据可能无法发出或未经处理直接发出。

**原因：**
*   **`ctx.writeAndFlush` 的含义**：从**当前处理器 (Current Handler)** 开始，**向前（朝 Head 方向）** 寻找出站处理器。
*   **当前位置**：In-3。
*   **路径**：
    1.  从 **In-3** 开始。
    2.  向前查找 -> **In-2** (跳过)。
    3.  向前查找 -> **In-1** (跳过)。
    4.  向前查找 -> **Head** (直接写出)。
*   **结果**：位于后方的 `Out-1`、`Out-2`、`Out-3` 全部被绕过。

---

### 4. 总结

可将 Pipeline 视为一个 **U 型结构**：

```text
       (读数据 Input)                   (写数据 Output)
           |                                ^
           v                                |
+-------------------------------------------------------------+
|      [ Head ] <----------------------- [ Tail ]             |
|         |                                 ^                 |
|         v                                 |                 |
|      [ In-1 ]                          [ Out-3 ]            |
|         |                                 ^                 |
|         v                                 |                 |
|      [ In-2 ]                          [ Out-2 ]            |
|         |                                 ^                 |
|         v                                 |                 |
|      [ In-3 ] -----------------------> [ Out-1 ]            |
+-------------------------------------------------------------+
             (In-3 位于此处)
```

1.  **入站**：左侧向下传播 (Head -> Tail)。
2.  **出站**：右侧向上传播 (Tail -> Head)。
3.  **`ch.write()`**：无论当前位置如何，强制回到最右下角的 **Tail**，重新执行完整的出站流程（经过所有 OutHandler）。
4.  **`ctx.write()`**：从当前位置直接“抄近道”向上传播（仅经过上方的 OutHandler，下方的 OutHandler 将被绕过）。

该实验成功验证了 Netty 的**全链路出站**机制。